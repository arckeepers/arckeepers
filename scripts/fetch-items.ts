#!/usr/bin/env npx tsx
/**
 * Item Crawler CLI
 * Fetches all items from the MetaForge API and saves as CSV.
 *
 * Usage:
 *   npx tsx scripts/fetch-items.ts
 *   # or
 *   npm run fetch-items
 */

import * as fs from "fs";
import * as path from "path";

interface ApiItem {
  id: string;
  name: string;
  rarity: string | null;
}

interface ApiResponse {
  data: ApiItem[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  };
}

type Rarity = "Common" | "Uncommon" | "Rare" | "Epic" | "Legendary";

interface RequiredItem {
  id: string;
  name: string;
  rarity: Rarity;
}

function mapRarity(apiRarity: string | null | undefined): Rarity {
  if (!apiRarity) return "Common";
  const normalized = apiRarity.toLowerCase();
  if (normalized === "common") return "Common";
  if (normalized === "uncommon") return "Uncommon";
  if (normalized === "rare") return "Rare";
  if (normalized === "epic") return "Epic";
  if (normalized === "legendary") return "Legendary";
  return "Common";
}

async function fetchAllItems(): Promise<RequiredItem[]> {
  const allItems: RequiredItem[] = [];
  let page = 1;
  let hasMore = true;
  const limit = 100;

  console.log("Fetching items from MetaForge API...\n");

  while (hasMore) {
    const url = `https://metaforge.app/api/arc-raiders/items?page=${page}&limit=${limit}`;
    
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`API error: ${response.status} ${response.statusText}`);
    }

    const data: ApiResponse = await response.json();

    const mappedItems = data.data.map((apiItem) => ({
      id: apiItem.id,
      name: apiItem.name,
      rarity: mapRarity(apiItem.rarity),
    }));

    allItems.push(...mappedItems);
    
    const progress = Math.round((allItems.length / data.pagination.total) * 100);
    process.stdout.write(`\r  Progress: ${allItems.length}/${data.pagination.total} items (${progress}%)`);

    hasMore = data.pagination.hasNextPage;
    page++;
  }

  console.log("\n");
  return allItems;
}

function toCsv(items: RequiredItem[]): string {
  const header = "id,name,rarity";
  const rows = items.map((item) => {
    // Escape quotes in name and wrap in quotes if contains comma
    const name = item.name.includes(",") || item.name.includes('"')
      ? `"${item.name.replace(/"/g, '""')}"`
      : item.name;
    return `${item.id},${name},${item.rarity}`;
  });
  return [header, ...rows].join("\n");
}

async function main() {
  try {
    const items = await fetchAllItems();
    
    // Ensure data directory exists
    const dataDir = path.join(process.cwd(), "src", "data");
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
    }

    // Save as CSV
    const csvPath = path.join(dataDir, "items.csv");
    const csv = toCsv(items);
    fs.writeFileSync(csvPath, csv);
    console.log(`✓ Saved ${items.length} items to ${csvPath}`);

    // Also save as TypeScript for direct import
    const tsContent = `// Auto-generated by scripts/fetch-items.ts
// Last updated: ${new Date().toISOString()}
// Source: https://metaforge.app/api/arc-raiders/items

import type { RequiredItem } from "../types";

export const allItems: RequiredItem[] = ${JSON.stringify(items, null, 2)};

// Create a lookup map for quick access
export const itemsById = new Map<string, RequiredItem>(
  allItems.map((item) => [item.id, item])
);

// Get item by ID
export const getItemById = (id: string): RequiredItem | undefined =>
  itemsById.get(id);
`;
    const tsPath = path.join(dataDir, "allItems.ts");
    fs.writeFileSync(tsPath, tsContent);
    console.log(`✓ Saved TypeScript module to ${tsPath}`);

    console.log("\nDone! You can now import items from 'src/data/allItems.ts'");
  } catch (error) {
    console.error("\n✗ Error:", error instanceof Error ? error.message : error);
    process.exit(1);
  }
}

main();
